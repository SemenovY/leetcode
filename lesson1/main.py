"""
Считаем время выполнения функции или алгоритма
Считаем пару чисел, которые записаны в одной строке
Считывание массивов
Является ли число или числа простым
Решето Эратосфена. Помогает найти все простые числа, не превосходящие n.
Функцию, которая для элемента возвращает всех его соседей. Матрица
Находим самое длинное слово в предложении.
Регулярка чтобы убрать знаки препинания и пробел
Алгоритм проверяет, будет ли фраза палиндромом.
Функция переводит целое число из десятичной системы в двоичную.
Получаем на входе два числа в двоичной системе счисления,
Необходимо вывести их сумму, также в двоичной системе
"""
import time
import re


class Sumbinary:
	"""
	Получаем на входе два числа в двоичной системе счисления
	Необходимо вывести их сумму, также в двоичной системе
	Решение должно работать за O(N),
	где N –— количество разрядов максимального числа на входе
	Формат ввода
	Два числа в двоичной системе счисления, каждое на отдельной строке
	Длина каждого числа не превосходит 10 000 символов
	Формат вывода
	Одно число в двоичной системе счисления.
	"""
	from typing import Tuple

	def get_sum(first_number, second_number):
		"""
		Получаем на вход два двоичных числа
		Заносим в списки
		Дополняем нулями
		Прогоняем по списку, сравниваем с условиями и создаем новый список
		В каждой проверке обновляем значение value
		В конце итерируемого списка если флаг переполнен, добавляем 1.
		:param first_number:
		:param second_number:
		:return:
		"""
		# получаем числа и переворачиваем для удобства подсчета
		first_number = first_number[::-1]
		second_number = second_number[::-1]
		# дополнить нулями
		size = max(len(first_number), len(second_number))
		first_number += [0] * (size - len(first_number))
		second_number += [0] * (size - len(second_number))
		# переменные
		result = []
		overflow = 0
		# код
		for i in zip(first_number, second_number):
			value = i[0] + i[1] + overflow
			#  другой вариант решения
			#   overflow = value // 2
			#   result.append(value%2)

			if value == 0:
				result.append(0)
				overflow = 0
			if value == 1:
				result.append(1)
				overflow = 0
			if value == 2:
				result.append(0)
				overflow = 1
			if value == 3:
				result.append(1)
				overflow = 1
		# если флаг переполнения установлен - добавить бит в начало нового числа
		if overflow == 1:
			result.append(1)
		result = map(int, result[::-1])
		result = " ".join(list(map(str, result)))
		result = str(result.replace(' ', ''))
		return result

	def read_input():
		"""
		Формат ввода
		Два числа в двоичной системе счисления, каждое на отдельной строке.
		Длина каждого числа не превосходит 10 000 символов.
		:return:
		"""
		# получить бинарное число в виде массива чисел (бит)
		first_number = [
			*map(int, input("Введите первое число в 2ой системе: "))]
		second_number = [
			*map(int, input("Введите второе число в 2ой системе: "))]
		return first_number, second_number

	first_number, second_number = read_input()
	# Формат вывода
	# Одно число в двоичной системе счисления.
	print(get_sum(first_number, second_number))


class Binary:
	"""
	Функция переводит целое число из десятичной системы в двоичную.
	"""
	def to_binary(number: int) -> str:
		"""
		Проверяем на ноль
		Затем по формуле делим на 2, собираем остаток
		Далее остаток в списке инвертируем
		Убираем все лишние знаки препинания
		:param number:
		:return:
		"""
		if number != 0:
			binary = []
			while number != 0:
				b, c = number // 2, number % 2
				number = b
				binary.append(c)
			binary = map(int, binary[::-1])
			binary = " ".join(list(map(str, binary)))
			binary = str(binary.replace(' ', ''))
			return binary
		return str(number)


	def read_input() -> int:
		return int(input().strip())


	print(to_binary(read_input()))




def is_palindrome(line: str) -> bool:
    """
    Логика проверки фразы на палиндром.
    Формат ввода
    В единственной строке записана фраза или слово.
    Буквы могут быть только латинские.
    Длина текста не превосходит 20000 символов.
    Фраза может состоять из строчных и прописных латинских букв,
    цифр, знаков препинания.
    Учитываются только буквы и цифры,
    заглавные и строчные буквы считаются одинаковыми.
    Решение должно работать за O(N), где N — длина строки на входе.
    Формат вывода
    Выведите «True», если фраза является палиндромом, и «False», если нет.
    :param line:
    :return:
    """
    altered_string = ''.join(re.sub(r'[^\w\s]', '', line).lower().strip().split())

    if altered_string == altered_string[::-1]:
        return True
    else:
        return False


    print(is_palindrome(input()))


def regular_del_punctuation_marks():
	"""
	Регуляркой убираем все знаки препинания и заменяем на пробел(re.sub)
	Join применяем для удаления пробелов
	Формат нужен для удаления запятых из пайтона.
	:return:
	"""
	line = 'A man, a plan, a canal: Panama'
	altered_string = re.sub(r'[^\w\s]', '', line)
	altered_string = ''.join(altered_string.lower().strip().split())
	print('Моя новая строка:\n {}'.format(altered_string))
	#  or
	altered_string = str(''.join(altered_string.lower().strip().split())).format(altered_string)
	print(f'Моя новая строка:\n {altered_string}')


def time_start_stop():
	"""
	Считаем время выполнения функции или алгоритма.
	"""

	time_start = time.time()

	# Ваш код

	time_finish = time.time()
	time_span = time_finish - time_start

	# Вывод результата на печать
	print(time_span, 'seconds')


def read_input_str_stdin(a, b):
	"""
	Считаем пару чисел, которые записаны в одной строке.
	"""

	# Ваш код

	a, b = map(int, input().split())
	print(a + b)


def read_input_set_stdin():
	"""
	Считываем массив из n чисел, а затем выводим его
	На первой строке указывается размер массива — число n
	На второй — перечисляются элементы массива через пробел
	Ввод может быть достаточно большим. Чтобы ускорить считывание,
	рекомендуется использовать буферизацию
	То же самое касается вывода большого объёма данных.
	"""
	# Считываем массив чисел, затем выводим его

	n = int(input())
	arr = list(map(int, input().split()))

	print(" ".join(list(map(str, arr))))


def find_simple_number_in_stdin(n):
	"""
	Если нам требуется узнать, является ли число простым
	Для остальных чисел будем выполнять проверку: если число n
	делится без остатка на какое-то число i, такое, что 1<i<n,
	то n — составное.
	Нужно отдельно протестировать, что число 2 будет считаться простым.
	Это важный особый случай, потому что не существует целых чисел между 1 и 2,
	а значит, проверка делимости ни разу не будет выполнена.
	:param n:
	:return:
	"""

	if n == 1:
		return False  # Число 1 не считается простым по определению
	i = 2
	while i * i <= n:  # Проверять числа, которые больше чем n, необязательно
		if n % i == 0:  # i*i эффективнее чем корень от n
			return False
		i = i + 1
	return True


def get_longest_word(line: str) -> str:
    """
    Создаем новый вложенный список
    Проходим по списку
    Сравниваем каждый элемент с образцом
    Выводим самый длинный элемент.
    :param line:
    :return:
    """
    word = []  # Заносим самое длинное слово
    comparison = [list(i) for i in line]  # Создаем вложенный словарь
    word.append(comparison[0])  # Заносим первое слово как образец для сравн.

    for j in range(len(comparison)):
        if len(comparison[j]) > len(word[0]):
            word[0] = comparison[j]

    return (''.join(word[0]))


class Eratosthenes:
	"""
	Решето Эратосфена. Помогает найти все простые числа, не превосходящие n.
	"""

	def eratosthenes(self, n):
		"""
		Решето Эратосфена. Помогает найти все простые числа, не превосходящие n.
		Алгоритм такой:
		Выписываем все целые числа от 0 до n.
		Сразу помечаем, что числа 0 и 1 не являются простыми
		(записываем на соответствующих этим числам позициях False).
		Заводим переменную num, равную первому не рассмотренному простому числу.
		Изначально она равна 2. Помечаем в списке числа от 2⋅num до n с шагом,
		равным num, составными.
		Например, для 2 пометим значением False чётные числа — 4, 6, 8 и так далее.
		Теперь в num присваиваем следующее простое число,
		то есть следующее не рассмотренное число в списке.
		Для этого достаточно увеличивать num с шагом 1, пропуская числа,
		отмеченные как составные.
		На первом найденном простом числе следует остановиться.
		Повторяем два предыдущих шага, пока это возможно.
		"""
		numbers = list(range(n + 1))
		numbers[0] = numbers[1] = False
		for num in range(2, n):
			if numbers[num]:
				for j in range(2 * num, n + 1, num):
					numbers[j] = False
		return numbers

	def eratosthenes_effective(self, n):
		"""
		Алгоритм можно оптимизировать.
		Для каждого простого числа p начнём отмечать числа,
		начиная с p**2, как составные.
		Ведь все составные числа, которые меньше его, будут уже рассмотрены.
		"""
		numbers = list(range(n + 1))  # Запишем числа
		numbers[0] = numbers[1] = False  # Отметим, что 0 и 1 не простые
		for num in range(2, n):
			# Пометим все числа, кратные 2, начиная с 4, значением False и тд
			if numbers[num]:
				for j in range(num * num, n + 1, num):
					numbers[j] = False
		return numbers

	def get_least_primes_linear(self, n):
		"""
		Линейное решето.
		Существует метод решения задачи нахождения всех простых чисел,
		не превосходящих n, которому требуется O(n) операций.
		Он называется линейное решето.
		Этот метод помечает каждое число как составное только один раз.
		Как и прежде, мы будем перебирать числа в порядке увеличения.
		Только в отличие от классического решета Эратосфена,
		составные числа не вычёркиваются.
		Вместо этого для каждого числа x
		мы запишем наименьший простой делитель p.
		В программе мы будем записывать этот делитель в ячейку массива lp[x]
		Если число простое, его наименьший простой делитель — оно само.
		Если число составное, его наименьший простой делитель p
		уже встречался раньше.
		Более того, нам встречалось и число i, такое, что x=i⋅p.
		На шаге i мы должны пометить число x как составное
		и указать его наименьший простой делитель.
		Каждое число будет помечено только один раз, на шаге i=x/p.
		Число i может быть взято только одним способом, потому что у любого
		числа существует только один наименьший простой делитель p.
		"""
		lp = [0] * (n + 1)
		primes = []
		# Алгоритм такой:
		# Для каждого числа i будем хранить lp[i] —
		# минимальный простой делитель числа i.
		# Заведём массив lp длины n + 1.
		# А также массив primes,
		# в который будем добавлять найденные простые числа.

		for i in range(2, n + 1):  # Перебираем i по возрастанию.
			if lp[i] == 0:
				# Если lp[i] = 0, можно сделать вывод, что число i простое
				lp[i] = i
				primes.append(i)  # и добавить его в массив primes.
			for p in primes:  # Рассматриваем все простые числа p
				x = p * i
				if (p > lp[i]) or (x > n):  # которые не больше lp[i].
					break
				lp[x] = p  # Обновляем lp[p * i] = p
		return primes, lp


class Neighbours:
	"""
	Дана матрица.
	Нужно написать функцию, которая для элемента возвращает всех его соседей.
	Соседним считается элемент, находящийся от текущего на одну ячейку влево,
	вправо, вверх или вниз.
	Диагональные элементы соседними не считаются.
	Например, в матрице A соседними элементами для (0, 0) будут 2 и 0.
	А для (2, 1) –— 1, 2, 7, 7.
	"""

	def get_neighbours(self, matrix, row, column):
		"""
		В цикле сначала задаем позицию в столбце сверху и снизу от сущности
		Затем проверяем начальный и конечный индексы, на исключение
		Добавляем в словарь если есть что
		Опять перебор, но уже слева справа
		И так же добавляем в словарь.
		:param matrix:
		:param row:
		:param column:
		:param n:
		:param m:
		:return: result
		"""

		result = []

		for col_m in (
		column - 1, column + 1):  # Координаты элемента по столбцам
			try:
				if col_m >= 0:
					result.append(matrix[row][col_m])  # left, right
			except Exception:
				pass

		for row_n in (row - 1, row + 1):  # Координаты элемента по строкам
			try:
				if row_n >= 0:
					result.append(matrix[row_n][column])  # up, down
			except Exception:
				pass

		return sorted(result)

	def read_input(self):
		"""
		Формат ввода
		В первой строке задано n — количество строк матрицы.
		Во второй — количество столбцов m. Числа m и n не превосходят 1000.
		В следующих n строках задана матрица.
		Элементы матрицы — целые числа, по модулю не превосходящие 1000.
		В последних двух строках записаны координаты элемента,
		соседей которого нужно найти. Индексация начинается с нуля.
		Формат вывода
		Напечатайте нужные числа в возрастающем порядке через пробел.
		"""
		n = int(input())  # rows
		m = int(input())  # columns
		matrix = []
		for i in range(n):  # from matrix to list
			matrix.append(list(map(int, input().strip().split())))
		row = int(input())  # Координаты элемента, строка
		column = int(input())  # Координаты элемента, столбец
		return matrix, row, column

	matrix, row, column = read_input()

	print(" ".join(map(str, get_neighbours(matrix, row, column))))
