"""
Считаем время выполнения функции или алгоритма
Считаем пару чисел, которые записаны в одной строке
Считывание массивов
Является ли число или числа простым
Решето Эратосфена. Помогает найти все простые числа, не превосходящие n.
"""
import time


def time_start_stop():
	"""
	Считаем время выполнения функции или алгоритма.
	"""

	time_start = time.time()

	# Ваш код

	time_finish = time.time()
	time_span = time_finish - time_start

	# Вывод результата на печать
	print(time_span, 'seconds')


def read_input_str_stdin(a, b):
	"""
	Считаем пару чисел, которые записаны в одной строке.
	"""

	# Ваш код

	a, b = map(int, input().split())
	print(a + b)


def read_input_set_stdin():
	"""
	Считываем массив из n чисел, а затем выводим его
	На первой строке указывается размер массива — число n
	На второй — перечисляются элементы массива через пробел
	Ввод может быть достаточно большим. Чтобы ускорить считывание,
	рекомендуется использовать буферизацию
	То же самое касается вывода большого объёма данных.
	"""
	# Считываем массив чисел, затем выводим его

	n = int(input())
	arr = list(map(int, input().split()))

	print(" ".join(list(map(str, arr))))


def find_simple_number_in_stdin(n):
	"""
	Если нам требуется узнать, является ли число простым
	Для остальных чисел будем выполнять проверку: если число n
	делится без остатка на какое-то число i, такое, что 1<i<n,
	то n — составное.
	Нужно отдельно протестировать, что число 2 будет считаться простым.
	Это важный особый случай, потому что не существует целых чисел между 1 и 2,
	а значит, проверка делимости ни разу не будет выполнена.
	:param n:
	:return:
	"""

	if n == 1:
		return False  # Число 1 не считается простым по определению
	i = 2
	while i * i <= n:  # Проверять числа, которые больше чем n, необязательно
		if n % i == 0:  # i*i эффективнее чем корень от n
			return False
		i = i + 1
	return True


class Eratosthenes:
	"""
	Решето Эратосфена. Помогает найти все простые числа, не превосходящие n.
	"""

	def eratosthenes(n):
		"""
		Решето Эратосфена. Помогает найти все простые числа, не превосходящие n.
		Алгоритм такой:
		Выписываем все целые числа от 0 до n.
		Сразу помечаем, что числа 0 и 1 не являются простыми
		(записываем на соответствующих этим числам позициях False).
		Заводим переменную num, равную первому не рассмотренному простому числу.
		Изначально она равна 2. Помечаем в списке числа от 2⋅num до n с шагом,
		равным num, составными.
		Например, для 2 пометим значением False чётные числа — 4, 6, 8 и так далее.
		Теперь в num присваиваем следующее простое число,
		то есть следующее не рассмотренное число в списке.
		Для этого достаточно увеличивать num с шагом 1, пропуская числа,
		отмеченные как составные.
		На первом найденном простом числе следует остановиться.
		Повторяем два предыдущих шага, пока это возможно.
		"""
		numbers = list(range(n + 1))
		numbers[0] = numbers[1] = False
		for num in range(2, n):
			if numbers[num]:
				for j in range(2 * num, n + 1, num):
					numbers[j] = False
		return numbers

	def eratosthenes_effective(n):
		"""
		Алгоритм можно оптимизировать.
		Для каждого простого числа p начнём отмечать числа,
		начиная с p**2, как составные.
		Ведь все составные числа, которые меньше его, будут уже рассмотрены.
		"""
		numbers = list(range(n + 1))  # Запишем числа
		numbers[0] = numbers[1] = False  # Отметим, что 0 и 1 не простые
		for num in range(2, n):
			# Пометим все числа, кратные 2, начиная с 4, значением False и тд
			if numbers[num]:
				for j in range(num * num, n + 1, num):
					numbers[j] = False
		return numbers

	def get_least_primes_linear(n):
		"""
		Линейное решето.
		Существует метод решения задачи нахождения всех простых чисел,
		не превосходящих n, которому требуется O(n) операций.
		Он называется линейное решето.
		Этот метод помечает каждое число как составное только один раз.
		Как и прежде, мы будем перебирать числа в порядке увеличения.
		Только в отличие от классического решета Эратосфена,
		составные числа не вычёркиваются.
		Вместо этого для каждого числа x
		мы запишем наименьший простой делитель p.
		В программе мы будем записывать этот делитель в ячейку массива lp[x]
		Если число простое, его наименьший простой делитель — оно само.
		Если число составное, его наименьший простой делитель p
		уже встречался раньше.
		Более того, нам встречалось и число i, такое, что x=i⋅p.
		На шаге i мы должны пометить число x как составное
		и указать его наименьший простой делитель.
		Каждое число будет помечено только один раз, на шаге i=x/p.
		Число i может быть взято только одним способом, потому что у любого
		числа существует только один наименьший простой делитель p.
		"""
		lp = [0] * (n + 1)
		primes = []
		# Алгоритм такой:
		# Для каждого числа i будем хранить lp[i] —
		# минимальный простой делитель числа i.
		# Заведём массив lp длины n + 1.
		# А также массив primes,
		# в который будем добавлять найденные простые числа.

		for i in range(2, n + 1):  # Перебираем i по возрастанию.
			if lp[i] == 0:
				# Если lp[i] = 0, можно сделать вывод, что число i простое
				lp[i] = i
				primes.append(i)  # и добавить его в массив primes.
			for p in primes:  # Рассматриваем все простые числа p
				x = p * i
				if (p > lp[i]) or (x > n):  # которые не больше lp[i].
					break
				lp[x] = p  # Обновляем lp[p * i] = p
		return primes, lp
